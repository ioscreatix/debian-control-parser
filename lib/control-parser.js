// Generated by CoffeeScript 1.3.3
(function() {
  var ControlDataParser, StreamSplitter, regex, events;

  StreamSplitter = require("stream-splitter");
  events = require("events");

  regex = {
    comment: /^#.*$/,
    blankLine: /^\s\..*$/,
    simpleField: /^([^\cA-\cZ\s:]+):\s*(.*)$/,
    continuationLine: /^(\s+)(.*)$/
  };

  module.exports = ControlDataParser = function(stream) {
    var cleanup, currentField, emitter, errorHandler, isMultiLine, splitter, stanza, tokenHandler;
    splitter = stream.pipe(StreamSplitter("\n"));
    splitter.encoding = "utf8";
    emitter = new events.EventEmitter();
    stanza = {};
    currentField = null;
    isMultiLine = false;
    tokenHandler = function(token) {
      var line, matches, name, value, _ref;
      if (token.trim().length === 0) {
        emitter.emit("stanza", stanza);
        stanza = {};
        currentField = null;
        isMultiLine = false;
        return;
      }
      if (regex.comment.test(token)) {
        return;
      }
      if (regex.blankLine.test(token)) {
        if (!currentField) {
          return errorHandler(new Error("Blank continuation line without originating field."));
        }
        isMultiLine = true;
        return stanza[currentField] += "\n";
      } else if (matches = regex.continuationLine.exec(token)) {
        if (!currentField) {
          return errorHandler(new Error("Continuation line without originating field."));
        }
        isMultiLine = true;
        line = matches[1] + matches[2];
        return stanza[currentField] += "\n" + line;
      } else if (matches = regex.simpleField.exec(token)) {
        _ref = matches.slice(1), name = _ref[0], value = _ref[1];
        if (currentField && !isMultiLine) {
          stanza[currentField] = stanza[currentField].trim();
          isMultiLine = false;
        }
        return stanza[currentField = name] = value;
      }
    };
    cleanup = function() {
      splitter.removeListener("token", tokenHandler);
      return splitter.removeListener("error", errorHandler);
    };
    errorHandler = function(err) {
      emitter.emit("error", err);
      return cleanup();
    };
    splitter.on("token", tokenHandler);
    splitter.on("error", errorHandler);
    splitter.on("done", function() {
      cleanup();
      if (currentField && !isMultiLine) {
        stanza[currentField] = stanza[currentField].trim();
      }
      if (stanza) {
        emitter.emit("stanza", stanza);
      }
      return emitter.emit("done");
    });
    return emitter;
  };

}).call(this);
